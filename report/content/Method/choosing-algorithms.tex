\section{Choosing Algorithms and Comparison Metric}\label{sec:choosing-algorithms}

My initial idea was to compare a lot of different algorithms in order to find when which algorithm is best for certain instances. This changed early as comparing algorithm specialized for completely different fairness metrics would likely not yield any substantially significant results. AS an example, an algorithm aimed at finding an optimal MMS allocation wouldn't really be fair to compare to an algorithm specifically designed to find the best EF1 allocation. A way around this could be to compare the algorithm using a bunch of different fairness metrics, but this would require much more time and the same issue would remain, each algorithm would most likely outperform other algorithms. 

The choice of algorithms was then highly dependent upon what metric i chose to use in order to compare the algorithms. From the literature i found that the research on MMS for mixed allocation wasn't as thoroughly researched as it has been for indivisible instances. This made me choose to compare algorithms using their achieved MMS. Since the allocations are supposed be as fair as possible as well, it doesn't make sense to try to maximize the total MMS of the allocation, but rather the MMS of the agent that "gets the worst deal".

Having chosen a fairness notion, the choice of algorithm was initially to compare a simple algorithm such as round-robin, with more specialized algorithms for mixed goods. The idea was here to see if the simpler, and often faster algorithms could compete with the complex ones. However, after some discussion it was determined that, as mentioned, comparing algorithms not aimed at MMS on their achieved MMS, would not really give any valuable insight. That is where the idea of comparing two algorithms with exact same fairness goal came from. The final choice was to see how an indivisible algorithm with a $\halfMMS$ goal compares to a specialized algorithm that also has a $\halfMMS$ goal. 

When comparing the algorithm, the \textit{Mixed MMS} value of the instance will of course be used for both algorithms to calculate the achieved MMS. Example of Mixed MMS allocations are shown in \autoref{fig:allocation_all_mms}.

Another analysis that will be performed is that since the mixed algorithm is specified to compute the MMS value for all agents, $\MMS_\sAgent\forall\sAgent\in\sAllAgents$, which even for smaller instances can be time consuming (a Mixed Integer Programming solution is used to find these exact MMS allocations.). I was therefore curious how the exact same algorithm would handle using only approximated MMS values instead. These approximated MMS values can either be found by normalizing each agents valuations such that $\sValuation_\sAgent(\sAllGoods)=\sNumAgents$, in which case the exact MMS value will be $\leq1$. I however chose to approximate the MMS value by using each agent's $\PROP_\sAgent$ value instead, which in practice should scale equally as the other method. Formally i approximate the MMS values with $\MMS_\sAgent\leq\PROP_\sAgent=\frac{\sValuation_\sAgent(\sAllGoods)}{\sNumAgents}$.

